{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Course website","text":""},{"location":"#teachers","title":"Teachers","text":"<ul> <li>Joana Carlevaro-Fita  </li> <li>Geert van Geest  </li> <li>Antonin Thi\u00e9baut  </li> <li>Rafael Riudavets Puig  </li> </ul>"},{"location":"#authors","title":"Authors","text":"<ul> <li>Geert van Geest  </li> <li>Antonin Thi\u00e9baut  </li> <li>Rafael Riudavets Puig  </li> <li>Patricia Palagi  </li> </ul>"},{"location":"#attribution","title":"Attribution","text":"<p>This course is partly inspired by the Carpentries Docker course</p>"},{"location":"#license-copyright","title":"License &amp; copyright","text":"<p>License: CC BY-SA 4.0</p> <p>Copyright: SIB Swiss Institute of Bioinformatics</p>"},{"location":"#material","title":"Material","text":"<ul> <li>This website</li> <li>Zoom meeting (through mail)</li> <li>Google doc (through mail)</li> <li>Slack channel</li> </ul>"},{"location":"#learning-outcomes","title":"Learning outcomes","text":""},{"location":"#general-learning-outcomes","title":"General learning outcomes","text":"<p>After this course, you will be able to:</p> <ul> <li>Understand the basic concepts and terminology associated with virtualization with containers</li> <li>Be able to customize, store and share a containerized environment with Docker</li> <li>Understand the essential differences between Docker and Apptainer</li> <li>Be able to use Apptainer to run containers on a shared computer environment (e.g. a HPC cluster)</li> </ul>"},{"location":"#learning-outcomes-explained","title":"Learning outcomes explained","text":"<p>To reach the general learning outcomes above, we have set a number of smaller learning outcomes. Each chapter (found at Course material) starts with these smaller learning outcomes. Use these at the start of a chapter to get an idea what you will learn. Use them also at the end of a chapter to evaluate whether you have learned what you were expected to learn.</p>"},{"location":"#learning-experiences","title":"Learning experiences","text":"<p>To reach the learning outcomes we will use lectures, exercises, polls and group work. During exercises, you are free to discuss with other participants. During lectures, focus on the lecture only.</p>"},{"location":"#exercises","title":"Exercises","text":"<p>Each block has practical work involved. Some more than others. The practicals are subdivided into chapters, and we\u2019ll have a (short) discussion after each chapter. All answers to the practicals are incorporated, but they are hidden. Do the exercise first by yourself, before checking out the answer. If your answer is different from the answer in the practicals, try to figure out why they are different.</p>"},{"location":"#asking-questions","title":"Asking questions","text":"<p>During lectures, you are encouraged to raise your hand if you have questions (if in-person), or use the Zoom functionality (if online). Find the buttons in the participants list (\u2018Participants\u2019 button):</p> <p>Alternatively, (depending on your zoom version or OS) use the \u2018Reactions\u2019 button:</p> <p>A main source of communication will be our slack channel. Ask background questions that interest you personally at #background. During the exercises, e.g. if you are stuck or don\u2019t understand what is going on, use the slack channel #q-and-a.  This channel is not only meant for asking questions but also for answering questions of other participants. If you are replying to a question, use the \u201creply in thread\u201d option:</p> <p>The teacher will review the answers, and add/modify if necessary. If you\u2019re really stuck and need specific tutor support, write the teachers or helpers personally.</p> <p>To summarise:</p> <ul> <li>During lectures: raise hand/zoom functionality</li> <li>Personal interest questions: #background</li> <li>During exercises: #q-and-a on slack</li> </ul>"},{"location":"course_schedule/","title":"Course schedule","text":"block start end subject block 1 9:00 AM 10:30 AM Introduction to containers 10:30 AM 10:45 AM BREAK block 2 10:45 AM 12:00 PM Managing containers and images 12:00 PM 1:00 PM BREAK block 3 1:00 PM 2:30 PM Working with <code>dockerfiles</code> 2:30 PM 2:45 PM BREAK block 4 2:45 PM 4:00 PM Running containers with apptainer"},{"location":"precourse/","title":"Precourse preparations","text":""},{"location":"precourse/#unix","title":"UNIX","text":"<p>As is stated in the course prerequisites at the announcement web page. We expect participants to have a basic understanding of working with the command line on UNIX-based systems. You can test your UNIX skills with a quiz here. If you don\u2019t have experience with UNIX command line, or if you\u2019re unsure whether you meet the prerequisites, follow our online UNIX tutorial.</p>"},{"location":"precourse/#software","title":"Software","text":"<p>Install Docker on your local computer and create an account on dockerhub. You can find instructions here. Note that you need admin rights to install and use Docker, and if you are installing Docker on Windows, you need a recent Windows version.</p> <p>If working with Windows</p> <p>During the course exercises you will be mainly interacting with docker through the command line. Although windows powershell is suitable for that, it is easier to follow the exercises if you have UNIX or \u2018UNIX-like\u2019 terminal. You can get this by using MobaXterm or WSL2. Make sure you install the latest versions before installing docker. </p> <p>If installing Docker is a problem</p> <p>During the course, we can give only limited support for installation issues. If you do not manage to install Docker before the course, you can still do almost all exercises on Play with Docker. A Docker login is required.</p>"},{"location":"precourse/#ssh-connections","title":"SSH connections","text":"<p>In addition to your local computer, you will be working on an Amazon Web Services (AWS) Elastic Cloud (EC2) server. This Ubuntu server behaves like a \u2018normal\u2019 remote server, and can be approached through <code>ssh</code>. If you are enrolled in the course, you have access to a shared document containing instruction to retrieve your username and private ssh key, granting you access to a personal home directory on the server.</p> If you want to know more about <code>ssh</code> <p>If you are not familiar with <code>ssh</code>, you can check the Heidelberg University tutorial for information on how to set it up and use it.</p> <p>Here are instructions on how to use VScode to connect with SSH to a remote server. First, place the <code>key_username.pem</code> file in the proper folder:</p> WindowsmacOS/Linux <p>Open a PowerShell terminal, <code>cd</code> to the directory where you have stored your private key (<code>key_username.pem</code> file) and move it to <code>~\\.ssh</code>: <pre><code>Move-Item -Path key_username.pem -Destination $HOME\\.ssh\n</code></pre></p> <p>Open a terminal, <code>cd</code> to the directory where you have stored your private key (<code>key_username.pem</code> file), change the permissions of the key file and move it to <code>~/.ssh</code>: <pre><code>chmod 400 key_username.pem\nmv key_username.pem ~/.ssh\n</code></pre></p> <p>Then:</p> <ul> <li>Open VScode and click on the green or blue button in the bottom left corner</li> <li>Select <code>Connect to Host...</code> and then <code>Configure SSH Hosts...</code></li> <li>Specify a location for the SSH config file (preferably the same directory as where your keys are stored): <code>~/.ssh/config</code></li> <li> <p>A skeleton config file will be provided. Edit it, so it looks like this (replace <code>username</code> with your username, and make sure the IP address in <code>HostName</code> match what the one given in the shared document):</p> WindowsMacOS/Linux <p><pre><code>Host sib_course_remote\n    User username\n    HostName 18.195.137.58\n    IdentityFile ~\\.ssh\\key_username.pem\n</code></pre> Note: if you are working with the Windows SSH executable (for example <code>C:\\WINDOWS\\System32\\OpenSSH\\ssh.exe</code>), you may have to use the full path of the key file instead of a relative one in <code>IdentityFile</code>: <pre><code>    IdentityFile C:\\Users\\&lt;windows_username&gt;\\.ssh\\key_username.pem\n</code></pre></p> <pre><code>Host sib_course_remote\n    User username\n    HostName 18.195.137.58\n    IdentityFile ~/.ssh/key_username.pem\n</code></pre> </li> </ul> <p>Finally:</p> <ul> <li>Save and close the config file</li> <li>Click again on the green or blue button in the bottom left corner</li> <li>Select <code>Connect to Host...</code>, and then <code>sib_course_remote</code>. You will be asked which operating system is used on the remote. Choose <code>Linux</code></li> </ul> <p>You can also find a video tutorial below:</p> If you are not working with VScode <p>If you are not working with VScode, you can login to the remote server with the following command in a terminal: <pre><code>ssh -i key_username.pem username@18.195.137.58\n</code></pre> If you want to edit files directly on the server, you can mount a directory with <code>sshfs</code>.</p>"},{"location":"course_material/day1/apptainer/","title":"Running containers with apptainer","text":""},{"location":"course_material/day1/apptainer/#learning-outcomes","title":"Learning outcomes","text":"<p>After having completed this chapter you will be able to:</p> <ul> <li>Login to a remote machine with <code>ssh</code></li> <li>Use <code>apptainer pull</code> to convert an image from dockerhub to the \u2018apptainer image format\u2019 (<code>.sif</code>)</li> <li>Execute a apptainer container</li> <li>Explain the difference in default mounting behaviour between <code>docker</code> and <code>apptainer</code></li> <li>Use <code>apptainer shell</code> to generate an interactive shell inside a <code>.sif</code> image</li> <li>Search and use images with both <code>docker</code> and <code>apptainer</code> from bioconda</li> </ul>"},{"location":"course_material/day1/apptainer/#material","title":"Material","text":"<p> Download the presentation</p> <ul> <li>Apptainer documentation</li> <li>An article on Docker vs Apptainer</li> <li>Using conda and containers with snakemake</li> </ul>"},{"location":"course_material/day1/apptainer/#exercises","title":"Exercises","text":"<p>Important</p> <p>This last part should be done on the remote server that has apptainer installed. If you haven\u2019t set up a VScode SSH connection to the server yet, you can find instructions here.</p>"},{"location":"course_material/day1/apptainer/#pulling-an-image","title":"Pulling an image","text":"<p>Apptainer can take several image formats (e.g. a <code>docker</code> image), and convert them into it\u2019s own <code>.sif</code> format. Unlike <code>docker</code> this image doesn\u2019t live in a local image cache, but it\u2019s stored as an actual file.</p> <p>Exercise: On the remote server, pull the docker image that has the adjusted default <code>CMD</code> that we have pushed to dockerhub in this exercise (<code>ubuntu-figlet-df:v3</code>) with <code>apptainer pull</code>. The syntax is:</p> <pre><code>apptainer pull docker://[USER NAME]/[IMAGE NAME]:[TAG]\n</code></pre> Answer <p><pre><code>apptainer pull docker://[USER NAME]/ubuntu-figlet:v3\n</code></pre> This will result in a file called <code>ubuntu-figlet_v3.sif</code></p> <p>Note</p> <p>If you weren\u2019t able to push the image in the previous exercises to your docker hub, you can use <code>geertvangeest</code> as username to pull the image.</p>"},{"location":"course_material/day1/apptainer/#executing-an-image","title":"Executing an image","text":"<p>These <code>.sif</code> files can be run as standalone executables:</p> <pre><code>./ubuntu-figlet_v3.sif\n</code></pre> <p>Note</p> <p>This is shorthand for:</p> <pre><code>apptainer run ubuntu-figlet_v3.sif\n</code></pre> <p>And you can overwrite the default command like this:</p> <pre><code>apptainer run [IMAGE NAME].sif [COMMAND]\n</code></pre> <p>Note</p> <p>In this case, you can also use</p> <pre><code>./[IMAGE NAME].sif [COMMAND]\n</code></pre> <p>However, most applications require <code>apptainer run</code>. Especially if you want to provide options like <code>--bind</code> (for mounting directories). </p> <p>Exercise: Run the <code>.sif</code> file without a command, and with a command that runs <code>figlet</code>. Do you get expected output? Do the same for the python or R image you\u2019ve created in the previous chapter.</p> <p>Entrypoint and apptainer</p> <p>The <code>daterange</code> image has an entrypoint set, and <code>apptainer run</code> does not overwrite it. In order to ignore both the entrypoint and cmd use <code>apptainer exec</code>.  </p> Answer <p>Running it without a command (<code>./ubuntu-figlet_v3.sif</code>) should give:</p> <p><pre><code>__  __         _                                                 _        _\n|  \\/  |_   _  (_)_ __ ___   __ _  __ _  ___  __      _____  _ __| | _____| |\n| |\\/| | | | | | | '_ ` _ \\ / _` |/ _` |/ _ \\ \\ \\ /\\ / / _ \\| '__| |/ / __| |\n| |  | | |_| | | | | | | | | (_| | (_| |  __/  \\ V  V / (_) | |  |   &lt;\\__ \\_|\n|_|  |_|\\__, | |_|_| |_| |_|\\__,_|\\__, |\\___|   \\_/\\_/ \\___/|_|  |_|\\_\\___(_)\n       |___/                     |___/\n</code></pre> Which is the default command that we changed in the <code>Dockerfile</code>.</p> <p>Running with a another <code>figlet</code> command:</p> <pre><code>./ubuntu-figlet_v3.sif figlet 'Something else'\n</code></pre> <p>Should give:</p> <pre><code>____                       _   _     _                    _\n/ ___|  ___  _ __ ___   ___| |_| |__ (_)_ __   __ _    ___| |___  ___\n\\___ \\ / _ \\| '_ ` _ \\ / _ \\ __| '_ \\| | '_ \\ / _` |  / _ \\ / __|/ _ \\\n___) | (_) | | | | | |  __/ |_| | | | | | | | (_| | |  __/ \\__ \\  __/\n|____/ \\___/|_| |_| |_|\\___|\\__|_| |_|_|_| |_|\\__, |  \\___|_|___/\\___|\n                                             |___/\n</code></pre> RPython <p>Pulling the <code>deseq2</code> image:</p> <pre><code>apptainer pull docker://[USER NAME]/deseq2:v1\n</code></pre> <p>Running it without command:</p> <pre><code>./deseq2_v1.sif\n</code></pre> <p>Running with a command:</p> <pre><code>./deseq2_v1.sif --rows 200\n</code></pre> <p>To overwrite both entrypoint and the command:</p> <pre><code>apptainer exec deseq2_v1.sif test_deseq2.R --rows 200\n</code></pre> <p>Pulling the <code>daterange.py</code> image:</p> <pre><code>apptainer pull docker://[USER NAME]/daterange:v1\n</code></pre> <p>Running it without command:</p> <pre><code>./daterange_v1.sif\n</code></pre> <p>Running with a command:</p> <pre><code>./daterange_v1.sif --date 20221005\n</code></pre> <p>To overwrite both entrypoint and the command:</p> <pre><code>apptainer exec daterange_v1.sif daterange.py --date 20221005\n</code></pre>"},{"location":"course_material/day1/apptainer/#mounting-with-apptainer","title":"Mounting with Apptainer","text":"<p>Apptainer is also different from Docker in the way it handles mounting. By default, Apptainer binds your home directory and a number of paths in the root directory to the container. This results in behaviour that is almost like if you are working on the directory structure of the host.  </p> <p>If your directory is not mounted by default</p> <p>It depends on the apptainer settings whether most directories are mounted by default to the container. If your directory is not mounted, you can do that with the <code>--bind</code> option of <code>apptainer exec</code>:</p> <pre><code>apptainer exec --bind /my/dir/to/mount/ [IMAGE NAME].sif [COMMAND]\n</code></pre> <p>Running the command <code>pwd</code> (full name of current working directory) will therefore result in a path on the host machine:</p> <pre><code>./ubuntu-figlet_v3.sif pwd\n</code></pre> <p>Exercise: Run the above command. What is the output? How would the output look like if you would run a similar command with Docker?</p> <p>Hint</p> <p>A similar Docker command would look like (run this on your local computer):</p> <pre><code>docker run --rm ubuntu-figlet:v3 pwd\n</code></pre> Answer <p>The output of <code>./ubuntu-figlet_v3.sif pwd</code> is the current directory on the host: i.e. <code>/home/username</code> if you have it in your home directory. The output of <code>docker run --rm ubuntu-figlet:v3 pwd</code> (on the local host) would be <code>/</code>, which is the default workdir (root directory) of the container. As we did not mount any host directory, this directory exists only within the container (i.e. separated from the host).</p>"},{"location":"course_material/day1/apptainer/#interactive-shell","title":"Interactive shell","text":"<p>If you want to debug or inspect an image, it can be helpful to have a shell inside the container. You can do that with <code>apptainer shell</code>:</p> <pre><code>apptainer shell ubuntu-figlet_v3.sif\n</code></pre> <p>Note</p> <p>To exit the shell type <code>exit</code>.</p> <p>Exercise: Can you run <code>figlet</code> inside this shell?</p> Answer <p>Yes: <pre><code>Apptainer&gt; figlet test\n _            _\n| |_ ___  ___| |_\n| __/ _ \\/ __| __|\n| ||  __/\\__ \\ |_\n \\__\\___||___/\\__|\n</code></pre></p> <p>During the lecture you have learned that apptainer takes over the user privileges of the user on the host. You can get user information with command like <code>whoami</code>, <code>id</code>, <code>groups</code> etc.</p> <p>Exercise: Run the <code>figlet</code> container interactively. Do you have the same user privileges as if you were on the host? How is that with <code>docker</code>?</p> Answer <p>A command like <code>whoami</code> will result in your username printed at stdout:</p> <pre><code>Apptainer&gt; whoami\nmyusername\nApptainer&gt; id\nuid=1030(myusername) gid=1031(myusername) groups=1031(myusername),1001(condausers)\nApptainer&gt; groups\nmyusername condausers\n</code></pre> <p>With apptainer, you have the same privileges inside the apptainer container as on the host. If you do this in the docker container (based on the same image), you\u2019ll get output like this:</p> <pre><code>root@a3d6e59dc19d:/# whoami\nroot\nroot@a3d6e59dc19d:/# groups\nroot\nroot@a3d6e59dc19d:/# id\nuid=0(root) gid=0(root) groups=0(root)\n</code></pre>"},{"location":"course_material/day1/apptainer/#a-bioinformatics-example-extra","title":"A bioinformatics example (extra)","text":"<p>All bioconda packages also have a pre-built container. Have a look at the bioconda website, and search for <code>fastqc</code>. In the search results, click on the appropriate record (i.e. package \u2018fastqc\u2019). Now, scroll down and find the docker command to obtain the fastqc image. </p> <p>Exercise: Check out the container image at quay.io, by following quay.io/biocontainers/fastqc. Choose a tag, and pull it with <code>apptainer pull</code>.</p> Answer <p>It\u2019s up to you which tag you choose. The tag with the latest version is <code>0.12.1--hdfd78af_0</code>.</p> <pre><code>apptainer pull docker://quay.io/biocontainers/fastqc:0.12.1--hdfd78af_0\n</code></pre> <p>Apptainer images at galaxy.org</p> <p>Most (if not all) biocontainer images are available as apptainer (singularity) image at https://depot.galaxyproject.org/singularity/. You can simply download them with <code>wget</code> or <code>curl</code>, e.g.:</p> <pre><code>wget https://depot.galaxyproject.org/singularity/fastqc%3A0.12.1--hdfd78af_0\n</code></pre> <p>Let\u2019s test the image. Download some sample reads first:</p> <pre><code>mkdir reads\ncd reads\nwget https://introduction-containers.s3.eu-central-1.amazonaws.com/ecoli_reads.tar.gz\ntar -xzvf ecoli_reads.tar.gz\nrm ecoli_reads.tar.gz\n</code></pre> <p>Now you can simply run the image as an executable preceding the commands you would like to run within the container. E.g. running <code>fastqc</code> would look like:</p> <pre><code>cd\n./fastqc_0.12.1--hdfd78af_0.sif fastqc ./reads/ecoli_*.fastq.gz\n</code></pre> <p>This will result in <code>html</code> files in the directory <code>./reads</code>. These are quality reports for the sequence reads. If you\u2019d like to view them, you can download them with <code>scp</code> or e.g. FileZilla, and view them with your local browser.</p>"},{"location":"course_material/day1/dockerfiles/","title":"Working with dockerfiles","text":""},{"location":"course_material/day1/dockerfiles/#learning-outcomes","title":"Learning outcomes","text":"<p>After having completed this chapter you will be able to:</p> <ul> <li>Build an image based on a dockerfile</li> <li>Use the basic dockerfile syntax</li> <li>Change the default command of an image and validate the change</li> <li>Map ports to a container to display interactive content through a browser</li> </ul>"},{"location":"course_material/day1/dockerfiles/#material","title":"Material","text":"<ul> <li>Official <code>Dockerfile</code> reference</li> <li>Ten simple rules for writing dockerfiles</li> </ul>"},{"location":"course_material/day1/dockerfiles/#exercises","title":"Exercises","text":"<p>To make your images shareable and adjustable, it\u2019s good practice to work with a <code>Dockerfile</code>. This is a script with a set of instructions to build your image from an existing image.</p>"},{"location":"course_material/day1/dockerfiles/#basic-dockerfile","title":"Basic <code>Dockerfile</code>","text":"<p>You can generate an image from a <code>Dockerfile</code> using the command <code>docker build</code>. A <code>Dockerfile</code> has its own syntax for giving instructions. Luckily, they are rather simple. The script always contains a line starting with <code>FROM</code> that takes the image name from which the new image will be built. After that you usually want to run some commands to e.g. configure and/or install software. The instruction to run these commands during building starts with <code>RUN</code>.  In our <code>figlet</code> example that would be:</p> <pre><code>FROM ubuntu:jammy-20250415.1\nRUN apt-get update\nRUN apt-get install figlet\n</code></pre> <p>On writing reproducible <code>Dockerfiles</code></p> <p>At the <code>FROM</code> statement in the the above <code>Dockerfile</code> you see that we have added a specific tag to the image (i.e. <code>jammy-20240427</code>). We could also have written:</p> <pre><code>FROM ubuntu\nRUN apt-get update\nRUN apt-get install figlet\n</code></pre> <p>This will automatically pull the image with the tag <code>latest</code>. However, if the maintainer of the <code>ubuntu</code> images decides to tag another <code>ubuntu</code> version as <code>latest</code>, rebuilding with the above <code>Dockerfile</code> will not give you the same result. Therefore it\u2019s always good practice to add the (stable) tag to the image in a <code>Dockerfile</code>. More rules on making your <code>Dockerfiles</code> more reproducible here.</p> <p>Exercise: Create a file on your computer called <code>Dockerfile</code>, and paste the above instruction lines in that file. Make the directory containing the <code>Dockerfile</code> your current directory. Build a new image based on that <code>Dockerfile</code> with:</p> x86_64 / AMD64ARM64 (MacOS M1 chip) <pre><code>docker build .\n</code></pre> <pre><code>export DOCKER_DEFAULT_PLATFORM=linux/amd64\ndocker build .\n</code></pre> <p>If using an Apple M chip (newer Macs)</p> <p>If you are using a computer with an Apple M chip, you have the less common ARM system architecture, which can limit transferability of images to (more common) <code>x86_64/AMD64</code> machines. When building images on a Mac with an M chip (especially if you have sharing in mind), it\u2019s best to set the <code>DOCKER_DEFAULT_PLATFORM</code> to <code>linux/amd64</code> with <code>export DOCKER_DEFAULT_PLATFORM=linux/amd64</code>. </p> <p>The argument of <code>docker build</code></p> <p>The command <code>docker build</code> takes a directory as input (providing <code>.</code> means the current directory). This directory should contain the <code>Dockerfile</code>, but it can also contain more of the build context, e.g. (python, R, shell) scripts that are required to build the image.</p> <p>What has happened? What is the name of the build image?</p> Answer <p>A new image was created based on the <code>Dockerfile</code>. You can check it with: <code>docker image ls</code>, which gives something like:</p> <pre><code>REPOSITORY                        TAG       IMAGE ID       CREATED             SIZE\n&lt;none&gt;                            &lt;none&gt;    92c980b09aad   7 seconds ago       101MB\nubuntu-figlet                     latest    e08b999c7978   About an hour ago   101MB\nubuntu                            latest    f63181f19b2f   30 hours ago        72.9MB\n</code></pre> <p>It has created an image without a name or tag. That\u2019s a bit inconvenient.</p> <p>Exercise: Build a new image with a specific name. You can do that with adding the option <code>-t</code> to <code>docker build</code>. Before that, remove the nameless image.</p> <p>Hint</p> <p>An image without a name is usually a \u201cdangling image\u201d. You can remove those with <code>docker image prune</code>.</p> Answer <p>Remove the nameless image with <code>docker image prune</code>.</p> <p>After that, rebuild an image with a name:</p> x86_64 / AMD64ARM (MacOS M1 chip) <pre><code>docker build -t ubuntu-figlet:v2 .\n</code></pre> <pre><code>DOCKER_DEFAULT_PLATFORM=linux/amd64\ndocker build -t ubuntu-figlet:v2 .\n</code></pre>"},{"location":"course_material/day1/dockerfiles/#using-cmd","title":"Using <code>CMD</code>","text":"<p>As you might remember the second positional argument of <code>docker run</code> is a command (i.e. <code>docker run IMAGE [CMD]</code>). If you leave it empty, it uses the default command. You can change the default command in the <code>Dockerfile</code> with an instruction starting with <code>CMD</code>. For example:</p> <pre><code>FROM ubuntu:jammy-20250415.1\nRUN apt-get update\nRUN apt-get install figlet\nCMD figlet My image works!\n</code></pre> <p>Exercise: Build a new image based on the above <code>Dockerfile</code>. Can you validate the change using <code>docker image inspect</code>? Can you overwrite this default with <code>docker run</code>?</p> Answer <p>Copy the new line to your <code>Dockerfile</code>, and build the new image like this:</p> x86_64 / AMD64ARM64 (MacOS M1 chip) <pre><code>docker build -t ubuntu-figlet:v3 .\n</code></pre> <pre><code>DOCKER_DEFAULT_PLATFORM=linux/amd64\ndocker build -t ubuntu-figlet:v3 .\n</code></pre> <p>The command <code>docker inspect ubuntu-figlet:v3</code> will give:</p> <pre><code>\"Cmd\": [\n    \"/bin/sh\",\n    \"-c\",\n    \"figlet My image works!\"\n]\n</code></pre> <p>So the default command (<code>/bin/bash</code>) has changed to <code>figlet My image works!</code></p> <p>Running the image (with clean-up (<code>--rm</code>)):</p> <pre><code>docker run --rm ubuntu-figlet:v3\n</code></pre> <p>Will result in:</p> <pre><code>__  __         _                                                 _        _\n|  \\/  |_   _  (_)_ __ ___   __ _  __ _  ___  __      _____  _ __| | _____| |\n| |\\/| | | | | | | '_ ` _ \\ / _` |/ _` |/ _ \\ \\ \\ /\\ / / _ \\| '__| |/ / __| |\n| |  | | |_| | | | | | | | | (_| | (_| |  __/  \\ V  V / (_) | |  |   &lt;\\__ \\_|\n|_|  |_|\\__, | |_|_| |_| |_|\\__,_|\\__, |\\___|   \\_/\\_/ \\___/|_|  |_|\\_\\___(_)\n       |___/                     |___/\n</code></pre> <p>And of course you can overwrite the default command:</p> <pre><code>docker run --rm ubuntu-figlet:v3 figlet another text\n</code></pre> <p>Resulting in:</p> <pre><code>_   _                 _            _\n__ _ _ __   ___ | |_| |__   ___ _ __  | |_ _____  _| |_\n/ _` | '_ \\ / _ \\| __| '_ \\ / _ \\ '__| | __/ _ \\ \\/ / __|\n| (_| | | | | (_) | |_| | | |  __/ |    | ||  __/&gt;  &lt;| |_\n\\__,_|_| |_|\\___/ \\__|_| |_|\\___|_|     \\__\\___/_/\\_\\\\__|\n</code></pre> <p>Two flavours of <code>CMD</code></p> <p>You have seen in the output of <code>docker inspect</code> that docker translates the command (i.e. <code>figlet \"my image works!\"</code>) into this: <code>[\"/bin/sh\", \"-c\", \"figlet 'My image works!'\"]</code>. The notation we used in the <code>Dockerfile</code> is the shell notation while the notation with the square brackets (<code>[]</code>) is the exec-notation. You can use both notations in your <code>Dockerfile</code>. Altough the shell notation is more readable, the exec notation is directly used by the image, and therefore less ambiguous.</p> <p>A <code>Dockerfile</code> with shell notation:</p> <pre><code>FROM ubuntu:jammy-20250415.1\nRUN apt-get update\nRUN apt-get install figlet\nCMD figlet My image works!\n</code></pre> <p>A <code>Dockerfile</code> with exec notation:</p> <pre><code>FROM ubuntu:jammy-20250415.1\nRUN apt-get update\nRUN apt-get install figlet\nCMD [\"/bin/sh\", \"-c\", \"figlet My image works!\"]\n</code></pre> <p>Exercise: Now push our created image (with a version tag) to docker hub. We will use it later for the <code>apptainer</code> exercises.</p> Answer <pre><code>docker tag ubuntu-figlet:v3 [USER NAME]/ubuntu-figlet:v3\ndocker push [USER NAME]/ubuntu-figlet:v3\n</code></pre>"},{"location":"course_material/day1/dockerfiles/#build-an-image-for-your-own-script","title":"Build an image for your own script Extra: Get information on your image with <code>docker inspect</code>  Extra: Building an image with a browser interface  Extra: Get information on your image with <code>docker inspect</code>  Extra: Adding metadata to your image  Extra: Building an image with a browser interface","text":"<p>Often containers are built for a specific purpose. For example, you can use a container to ship all dependencies together with your developed set of scripts/programs. For that you will need to add your scripts to the container. That is quite easily done with the instruction <code>COPY</code>. However, in order to make your container more user-friendly, there are several additional instructions that can come in useful. We will treat the most frequently used ones below. Depending on your preference, either choose R or Python below. </p> RPython <p>In the exercises will use a simple script called <code>test_deseq2.R</code>. You can download it here, or copy-paste it:</p> test_deseq2.R<pre><code>#!/usr/bin/env Rscript\n\n# load packages required for this script\nwrite(\"Loading packages required for this script\", stderr())\nsuppressPackageStartupMessages({\n    library(DESeq2)\n    library(optparse)\n})\n\n# workaround for issue 112: https://github.com/thelovelab/DESeq2/issues/112\n# this can probably be removed in the future\nsetOldClass(\"ExpData\")\n\n# load dependency packages for testing installations\nwrite(\"Loading dependency packages for testing installations\", stderr())\nsuppressPackageStartupMessages({\n    library(apeglm)\n    library(IHW)\n    library(limma)\n    library(data.table)\n    library(ggplot2)\n    library(ggrepel)\n    library(pheatmap)\n    library(RColorBrewer)\n    library(scales)\n    library(stringr)\n})\n\n# parse options with optparse\noption_list &lt;- list(\n    make_option(c(\"--rows\"),\n        type = \"integer\",\n        help = \"Number of rows in dummy matrix [default = %default]\",\n        default = 100\n    )\n)\n\nopt_parser &lt;- OptionParser(\n    option_list = option_list,\n    description = \"Runs DESeq2 on dummy data\"\n)\nopt &lt;- parse_args(opt_parser)\n\n# create a random dummy count matrix\ncnts &lt;- matrix(rnbinom(n = opt$row * 10, mu = 100, size = 1 / 0.5), ncol = 10)\ncond &lt;- factor(rep(1:2, each = 5))\n\n# object construction\ndds &lt;- DESeqDataSetFromMatrix(cnts, DataFrame(cond), ~cond)\n\n# standard analysis\ndds &lt;- DESeq(dds)\nres &lt;- results(dds)\n\n# print results to stdout\nprint(res)\n</code></pre> <p>After you have downloaded it, make sure to set the permissions to executable:</p> <p><pre><code>chmod +x test_deseq2.R\n</code></pre> It is a relatively simple script that runs DESeq2 on a dummy dataset. An example for execution would be:</p> <pre><code>./test_deseq2.R --rows 75\n</code></pre> <p>Giving a list of results from DESeq2 on a dummy dataset with 75 rows.</p> <p>Here, <code>--rows</code> is an optional argument that specifies the number of rows generated in the input count matrix. When running the script, it will return a bunch of messages and at the end an overview of differential gene expression analysis results:</p> <pre><code>    baseMean log2FoldChange     lfcSE         stat    pvalue      padj\n    &lt;numeric&gt;      &lt;numeric&gt; &lt;numeric&gt;    &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\n1     66.1249       0.281757  0.727668     0.387206  0.698604  0.989804\n2     76.9682       0.305763  0.619209     0.493796  0.621451  0.989804\n3     64.7843      -0.694525  0.479445    -1.448603  0.147448  0.931561\n4    123.0252       0.631247  0.688564     0.916758  0.359269  0.931561\n5     93.2002      -0.453430  0.686043    -0.660936  0.508653  0.941951\n...       ...            ...       ...          ...       ...       ...\n96    64.0177    0.757585137  0.682683  1.109718054  0.267121  0.931561\n97   114.3689   -0.580010850  0.640313 -0.905823841  0.365029  0.931561\n98    79.9620    0.000100617  0.612442  0.000164288  0.999869  0.999869\n99    92.6614    0.563514308  0.716109  0.786910869  0.431334  0.939106\n100   96.4410   -0.155268696  0.534400 -0.290547708  0.771397  0.989804\n</code></pre> <p>From the script you can see it has <code>DESeq2</code> and <code>optparse</code> as dependencies. If we want to run the script inside a container, we would have to install them. We do this in the <code>Dockerfile</code> below. We give it the following instructions:</p> <ul> <li>use the r2u base image version jammy</li> <li>install the package <code>DESeq2</code>, <code>optparse</code> and some additional packages we will need later on. We perform the installations with <code>install2.r</code>, which is a helper command that is present inside most rocker images. More info here. </li> <li>copy the script <code>test_deseq2.R</code> to <code>/opt</code> inside the container:</li> </ul> <pre><code>FROM rocker/r2u:jammy\n\nRUN install2.r \\\n    DESeq2 \\\n    optparse \\\n    apeglm \\\n    IHW \\\n    limma \\\n    data.table \\\n    ggrepel \\\n    pheatmap \\\n    stringr\n\nCOPY test_deseq2.R /opt \n</code></pre> <p>Note</p> <p>In order to use <code>COPY</code>, the file that needs to be copied needs to be in the same directory as the <code>Dockerfile</code> or one of its subdirectories.</p> <p>R image stack</p> <p>The most used R image stack is from the rocker project. It contains many different base images (e.g. with shiny, Rstudio, tidyverse etc.). It depends on the type of image whether installations with <code>apt-get</code> or <code>install2.r</code> are possible. To understand more about how to install R packages in different containers, check it this cheat sheet, or visit rocker-project.org.</p> <p>Exercise: Download the <code>test_deseq2.R</code> and build the image with <code>docker build</code>. Name the image <code>deseq2</code>. After that, start an interactive session and execute the script inside the container. </p> <p>Hint</p> <p>Make an interactive session with the options <code>-i</code> and <code>-t</code> and use <code>/bin/bash</code> as the command. </p> Answer <p>Build the container:</p> x86_64 / AMD64ARM64 (MacOS M1 chip) <pre><code>docker build -t deseq2 .\n</code></pre> <pre><code>DOCKER_DEFAULT_PLATFORM=linux/amd64\ndocker build -t deseq2 .\n</code></pre> <p>Run the container:</p> <pre><code>docker run -it --rm deseq2 /bin/bash\n</code></pre> <p>Inside the container we look up the script:</p> <pre><code>cd /opt\nls\n</code></pre> <p>This should return <code>test_deseq2.R</code>. </p> <p>Now you can execute it from inside the container:</p> <pre><code>./test_deseq2.R --rows 100\n</code></pre> <p>That\u2019s kind of nice. We can ship our R script inside our container. However, we don\u2019t want to run it interactively every time. So let\u2019s make some changes to make it easy to run it as an executable. For example, we can add <code>/opt</code> to the global <code>$PATH</code> variable with <code>ENV</code>. </p> <p>The <code>$PATH</code> variable</p> <p>The path variable is a special variable that consists of a list of path seperated by colons (<code>:</code>). These paths are searched if you are trying to run an executable. More info this topic at e.g. wikipedia. </p> <pre><code>FROM rocker/r2u:jammy\n\nRUN install2.r \\\n    DESeq2 \\\n    optparse \\\n    apeglm \\\n    IHW \\\n    limma \\\n    data.table \\\n    ggrepel \\\n    pheatmap \\\n    stringr\n\nCOPY test_deseq2.R /opt \n\nENV PATH=/opt:$PATH\n</code></pre> <p>Note</p> <p>The <code>ENV</code> instruction can be used to set any variable. </p> <p>Exercise: Rebuild the image and start an interactive bash session inside the new image. Is the path variable updated? (i.e. can we execute <code>test_deseq2.R</code> from anywhere?)</p> Answer <p>After re-building we start an interactive session:</p> <pre><code>docker run -it --rm deseq2 /bin/bash\n</code></pre> <p>The path is upated, <code>/opt</code> is appended to the beginning of the variable:</p> <pre><code>echo $PATH\n</code></pre> <p>returns:</p> <pre><code>/opt:/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n</code></pre> <p>Now you can try to execute it from the root directory (or any other):</p> <pre><code>test_deseq2.R\n</code></pre> <p>Instead of starting an interactive session with <code>/bin/bash</code> we can now more easily run the script non-interactively:</p> <pre><code>docker run --rm deseq2 test_deseq2.R --rows 100\n</code></pre> <p>Now it will directly print the output of <code>test_deseq2.R</code> to stdout. </p> <p>In the case you want to pack your script inside a container, you are building a container specifically for your script, meaning you almost want the container to behave as the program itself. In order to do that, you can use <code>ENTRYPOINT</code>. <code>ENTRYPOINT</code> is similar to <code>CMD</code>, but has two important differences:</p> <ul> <li><code>ENTRYPOINT</code> can not be overwritten by the positional arguments (i.e. <code>docker run image [CMD]</code>), but has to be overwritten by <code>--entrypoint</code>. </li> <li>The positional arguments (or <code>CMD</code>) are pasted to the <code>ENTRYPOINT</code> command. This means that you can use <code>ENTRYPOINT</code> as the executable and the positional arguments (or <code>CMD</code>) as the options. </li> </ul> <p>Let\u2019s try it out:</p> <pre><code>FROM rocker/r2u:jammy\n\nRUN install2.r \\\n    DESeq2 \\\n    optparse \\\n    apeglm \\\n    IHW \\\n    limma \\\n    data.table \\\n    ggrepel \\\n    pheatmap \\\n    stringr\n\nCOPY test_deseq2.R /opt \n\nENV PATH=/opt:$PATH\n\n# note that if you want to be able to combine the two\n# both ENTRYPOINT and CMD need to written in the exec form\nENTRYPOINT [\"test_deseq2.R\"]\n\n# default option (if positional arguments are not specified)\nCMD [\"--rows\", \"100\"]\n</code></pre> <p>Exercise: Re-build, and run the container non-interactively without any positional arguments. After that, try to pass a different number of rows to <code>--rows</code>. How do the commands look?</p> Answer <p>Just running the container non-interactively would be:</p> <pre><code>docker run --rm deseq2\n</code></pre> <p>Passing a different argument (i.e. overwriting <code>CMD</code>) would be:</p> <pre><code>docker run --rm deseq2 --rows 200\n</code></pre> <p>Here, the container behaves as the executable itself to which you can pass arguments. </p> <p>Note</p> <p>You can overwrite <code>ENTRYPOINT</code> with <code>--entrypoint</code> as an argument to <code>docker run</code>. </p> <p>Exercise: Push the image to dockerhub, so we can use it later with the apptainer exercises.</p> Answer <p>Pushing it to dockerhub: </p> <pre><code>docker tag deseq2 [USER NAME]/deseq2:v1\ndocker push [USER NAME]/deseq2:v1\n</code></pre> <p></p> <p>We have used <code>docker inspect</code> already in the previous chapter to find the default <code>Cmd</code> of the ubuntu image. However we can get more info on the image: e.g. the entrypoint, environmental variables, cmd, workingdir etc., you can use the <code>Config</code> record from the output of <code>docker inspect</code>. For our image this looks like:</p> <pre><code>\"Config\": {\n    \"Hostname\": \"\",\n    \"Domainname\": \"\",\n    \"User\": \"\",\n    \"AttachStdin\": false,\n    \"AttachStdout\": false,\n    \"AttachStderr\": false,\n    \"Tty\": false,\n    \"OpenStdin\": false,\n    \"StdinOnce\": false,\n    \"Env\": [\n        \"PATH=/opt:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n        \"LC_ALL=en_US.UTF-8\",\n        \"LANG=en_US.UTF-8\",\n        \"DEBIAN_FRONTEND=noninteractive\",\n        \"TZ=UTC\"\n    ],\n    \"Cmd\": [\n        \"--rows\",\n        \"100\"\n    ],\n    \"ArgsEscaped\": true,\n    \"Image\": \"\",\n    \"Volumes\": null,\n    \"WorkingDir\": \"/opt\",\n    \"Entrypoint\": [\n        \"test_deseq2.R\"\n    ],\n    \"OnBuild\": null,\n    \"Labels\": {\n        \"maintainer\": \"Dirk Eddelbuettel &lt;edd@debian.org&gt;\",\n        \"org.label-schema.license\": \"GPL-2.0\",\n        \"org.label-schema.vcs-url\": \"https://github.com/rocker-org/\",\n        \"org.label-schema.vendor\": \"Rocker Project\"\n    }\n}\n</code></pre> <p>You can annotate your <code>Dockerfile</code> and the image by using the instruction <code>LABEL</code>. You can give it any key and value with <code>&lt;key&gt;=&lt;value&gt;</code>. However, it is recommended to use the Open Container Initiative (OCI) keys.</p> <p>Exercise: Annotate our <code>Dockerfile</code> with the OCI keys on the creation date, author and description. After that, check whether this has been passed to the actual image with <code>docker inspect</code>. </p> <p>Note</p> <p>You can type <code>LABEL</code> for each key-value pair, but you can also have it on one line by seperating the key-value pairs by a space, e.g.:</p> <pre><code>LABEL keyx=\"valuex\" keyy=\"valuey\"\n</code></pre> Answer <p>The <code>Dockerfile</code> would look like:</p> <pre><code>FROM rocker/r2u:jammy\n\nLABEL org.opencontainers.image.created=\"2023-04-12\" \\\n        org.opencontainers.image.authors=\"Geert van Geest\" \\\n        org.opencontainers.image.description=\"Container with DESeq2 and friends\"\n\nRUN install2.r \\\n    DESeq2 \\\n    optparse \\\n    apeglm \\\n    IHW \\\n    limma \\\n    data.table \\\n    ggrepel \\\n    pheatmap \\\n    stringr\n\nWORKDIR /opt\n\nCOPY test_deseq2.R .\n\nENV PATH=/opt:$PATH\n\n# note that if you want to be able to combine the two\n# both ENTRYPOINT and CMD need to written in the exec form\nENTRYPOINT [\"test_deseq2.R\"]\n\n# default option (if positional arguments are not specified)\nCMD [\"--rows\", \"100\"]\n</code></pre> <p>The <code>Config</code> record in the output of <code>docker inspect</code> was updated with:</p> <pre><code>    \"Labels\": {\n        \"org.opencontainers.image.authors\": \"Geert van Geest\",\n        \"org.opencontainers.image.created\": \"2023-04-12\",\n        \"org.opencontainers.image.description\": \"Container with DESeq2 and friends\",\n        \"org.opencontainers.image.licenses\": \"GPL-2.0-or-later\",\n        \"org.opencontainers.image.source\": \"https://github.com/rocker-org/rocker\",\n        \"org.opencontainers.image.vendor\": \"Rocker Project\"\n    }\n</code></pre> <p></p> <p>In this exercise, we will use a different base image (<code>rocker/rstudio:4</code>), and we\u2019ll install the same packages. Rstudio server is a nice browser interface that you can use for a.o. programming in R. With the image we are creating we will be able to run Rstudio server inside a container.  Check out the <code>Dockerfile</code>:</p> <pre><code>FROM rocker/rstudio:4\n\nRUN apt-get update &amp;&amp; \\\n    apt-get install -y libz-dev\n\nRUN install2.r \\\n    optparse \\\n    BiocManager\n\nRUN R -q -e 'BiocManager::install(\"biomaRt\")'\n</code></pre> <p>This will create an image from the existing <code>rstudio</code> image. It will also install <code>libz-dev</code> with <code>apt-get</code>, <code>BiocManager</code> with <code>install2.r</code> and <code>biomaRt</code> with an R command. Despiste we\u2019re installing the same packages, the installation steps need to be different from the <code>r-base</code> image. This is because in the <code>rocker/rstudio</code> images R is installed from source, and therefore you can\u2019t install packages with <code>apt-get</code>. More information on how to install R packages in R containers in this cheat sheet, or visit rocker-project.org.</p> <p>Exercise: Build an image based on this <code>Dockerfile</code> and give it a meaningful name.</p> Answer x86_64 / AMD64ARM64 (MacOS M1 chip) <pre><code>docker build -t rstudio-server .\n</code></pre> <pre><code>export DOCKER_DEFAULT_PLATFORM=linux/amd64\ndocker build -t rstudio-server .\n</code></pre> <p>You can now run a container from the image. However, you will have to tell docker where to publish port 8787 from the docker container with <code>-p [HOSTPORT:CONTAINERPORT]</code>. We choose to publish it to the same port number:</p> <pre><code>docker run --rm -it -p 8787:8787 rstudio-server\n</code></pre> <p>Networking</p> <p>More info on docker container networking here</p> <p>By running the above command, a container will be started exposing rstudio server at port 8787 at localhost. You can approach the instance of jupyterhub by typing <code>localhost:8787</code> in your browser. You will be asked for a password. You can find this password in the terminal from which you have started the container.</p> <p>We can make this even more interesting by mounting a local directory to the container running the jupyter-lab image:</p> <pre><code>docker run \\\n-it \\\n--rm \\\n-p 8787:8787 \\\n--mount type=bind,source=/Users/myusername/working_dir,target=/home/rstudio/working_dir \\\nrstudio-server\n</code></pre> <p>By doing this you have a completely isolated and shareable R environment running Rstudio server, but with your local files available to it. Pretty neat right? </p> <p>In the exercises will use a simple script called <code>daterange.py</code>. You can download it here. Or copy-paste it from here:</p> daterange.py<pre><code>#!/usr/bin/env python3\n\nimport pandas as pd\nimport argparse\n\nparser = argparse.ArgumentParser(description = \"Get a daterange\")\n\nparser.add_argument('-d', '--date', type=str, required=True, \n                    help='Date. Format: [YYYYMMDD]')\n\nargs = parser.parse_args()\n\ndates = pd.date_range(args.date, periods=7)\n\nfor d in dates:\n    print(d)\n</code></pre> <p>After you have downloaded it, make sure to set the permissions to executable:</p> <pre><code>chmod +x daterange.py\n</code></pre> <p>Have a look at <code>daterange.py</code>. It is a simple script that uses <code>pandas</code> and <code>argparse</code>. It takes a date (in the format <code>YYYYMMDD</code>) as provided by the option <code>--date</code>, and returns a list of all dates in the week starting from that date. An example for execution would be:</p> <pre><code>./daterange.py --date 20220226\n</code></pre> <p>Giving a list of dates starting from 26-FEB-2022:</p> <pre><code>2022-02-26 00:00:00\n2022-02-27 00:00:00\n2022-02-28 00:00:00\n2022-03-01 00:00:00\n2022-03-02 00:00:00\n2022-03-03 00:00:00\n2022-03-04 00:00:00\n</code></pre> <p>From the script, you can see it has the dependecy <code>pandas</code>, which is not a built-in module. In the <code>Dockerfile</code> below we give the instruction to install <code>pandas</code> with <code>pip</code> and copy <code>daterange.py</code> to <code>/opt</code> inside the container:</p> <pre><code>FROM python:3.9.16\n\nRUN pip install pandas \n\nCOPY daterange.py /opt \n</code></pre> <p>Note</p> <p>In order to use <code>COPY</code>, the file that needs to be copied needs to be in the same directory as the <code>Dockerfile</code> or one of its subdirectories.</p> <p>Exercise: Download the <code>daterange.py</code> and build the image with <code>docker build</code>. After that, execute the script inside the container. </p> <p>Hint</p> <p>Make an interactive session with the options <code>-i</code> and <code>-t</code> and use <code>/bin/bash</code> as the command. </p> Answer <p>Build the container:</p> x86_64 / AMD64ARM64 (MacOS M1 chip) <pre><code>docker build -t daterange .\n</code></pre> <pre><code>export DOCKER_DEFAULT_PLATFORM=linux/amd64\ndocker build -t daterange .\n</code></pre> <p>Run the container:</p> <pre><code>docker run -it --rm daterange /bin/bash\n</code></pre> <p>Inside the container we look up the script:</p> <pre><code>cd /opt\nls\n</code></pre> <p>This should return <code>daterange.py</code>. </p> <p>Now you can execute it from inside the container:</p> <pre><code>./daterange.py --date 20220226\n</code></pre> <p>That\u2019s kind of nice. We can ship our python script inside our container. However, we don\u2019t want to run it interactively every time. So let\u2019s make some changes to make it easy to run it as an executable. For example, we can add <code>/opt</code> to the global <code>$PATH</code> variable with <code>ENV</code>. </p> <p>The <code>$PATH</code> variable</p> <p>The path variable is a special variable that consists of a list of path seperated by colons (<code>:</code>). These paths are searched if you are trying to run an executable. More info this topic at e.g. wikipedia. </p> <pre><code>FROM python:3.9.16\n\nRUN pip install pandas \n\nCOPY daterange.py /opt \n\nENV PATH=/opt:$PATH\n</code></pre> <p>Note</p> <p>The <code>ENV</code> instruction can be used to set any variable. </p> <p>Exercise: Start an interactive bash session inside the new container. Is the path variable updated? (i.e. can we execute <code>daterange.py</code> from anywhere?)</p> Answer <p>After re-building we start an interactive session:</p> <pre><code>docker run -it --rm daterange /bin/bash\n</code></pre> <p>The path is upated, <code>/opt</code> is appended to the beginning of the variable:</p> <pre><code>echo $PATH\n</code></pre> <p>returns:</p> <pre><code>/opt:/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n</code></pre> <p>Now you can try to execute it from the root directory (or any other):</p> <pre><code>daterange.py --date 20220226\n</code></pre> <p>Instead of starting an interactive session with <code>/bin/bash</code> we can now more easily run the script non-interactively:</p> <pre><code>docker run --rm daterange daterange.py --date 20220226\n</code></pre> <p>Now it will directly print the output of <code>daterange.py</code> to stdout. </p> <p>In the case you want to pack your script inside a container, you are building a container specifically for your script, meaning you almost want the container to behave as the program itself. In order to do that, you can use <code>ENTRYPOINT</code>. <code>ENTRYPOINT</code> is similar to <code>CMD</code>, but has two important differences:</p> <ul> <li><code>ENTRYPOINT</code> can not be overwritten by the positional arguments (i.e. <code>docker run image [CMD]</code>), but has to be overwritten by <code>--entrypoint</code>. </li> <li>The positional arguments (or <code>CMD</code>) are pasted to the <code>ENTRYPOINT</code> command. This means that you can use <code>ENTRYPOINT</code> as the executable and the positional arguments (or <code>CMD</code>) as the options. </li> </ul> <p>Let\u2019s try it out:</p> <pre><code>FROM python:3.9.16\n\nRUN pip install pandas \n\nCOPY daterange.py /opt \n\nENV PATH=/opt:$PATH\n\n# note that if you want to be able to combine the two\n# both ENTRYPOINT and CMD need to written in the exec form\nENTRYPOINT [\"daterange.py\"]\n\n# default option (if positional arguments are not specified)\nCMD [\"--date\", \"20220226\"]\n</code></pre> <p>Exercise: Re-build, and run the container non-interactively without any positional arguments. After that, try to pass a different date to <code>--date</code>. How do the commands look?</p> Answer <p>Just running the container non-interactively would be:</p> <pre><code>docker run --rm daterange\n</code></pre> <p>Passing a different argument (i.e. overwriting <code>CMD</code>) would be:</p> <pre><code>docker run --rm daterange --date 20210330\n</code></pre> <p>Here, the container behaves as the executable itself to which you can pass arguments. </p> <p>Note</p> <p>You can overwrite <code>ENTRYPOINT</code> with <code>--entrypoint</code> as an argument to <code>docker run</code>. </p> <p>Exercise: Push the image to dockerhub, so we can use it later with the apptainer exercises.</p> Answer <p>Pushing it to dockerhub: </p> <pre><code>docker tag daterage [USER NAME]/daterange:v1\ndocker push [USER NAME]/daterange:v1\n</code></pre> <p></p> <p>We have used <code>docker inspect</code> already in the previous chapter to find the default <code>Cmd</code> of the ubuntu image. However we can get more info on the image: e.g. the entrypoint, environmental variables, cmd, workingdir etc., you can use the <code>Config</code> record from the output of <code>docker inspect</code>. For our image this looks like:</p> <pre><code>\"Config\": {\n        \"Hostname\": \"\",\n        \"Domainname\": \"\",\n        \"User\": \"\",\n        \"AttachStdin\": false,\n        \"AttachStdout\": false,\n        \"AttachStderr\": false,\n        \"Tty\": false,\n        \"OpenStdin\": false,\n        \"StdinOnce\": false,\n        \"Env\": [\n            \"PATH=/opt:/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n            \"LANG=C.UTF-8\",\n            \"GPG_KEY=E3FF2839C048B25C084DEBE9B26995E310250568\",\n            \"PYTHON_VERSION=3.9.4\",\n            \"PYTHON_PIP_VERSION=21.1.1\",\n            \"PYTHON_GET_PIP_URL=https://github.com/pypa/get-pip/raw/1954f15b3f102ace496a34a013ea76b061535bd2/public/get-pip.py\",\n            \"PYTHON_GET_PIP_SHA256=f499d76e0149a673fb8246d88e116db589afbd291739bd84f2cd9a7bca7b6993\"\n        ],\n        \"Cmd\": [\n            \"--date\",\n            \"20220226\"\n        ],\n        \"ArgsEscaped\": true,\n        \"Image\": \"\",\n        \"Volumes\": null,\n        \"WorkingDir\": \"/opt\",\n        \"Entrypoint\": [\n            \"daterange.py\"\n        ],\n        \"OnBuild\": null,\n        \"Labels\": null\n    },\n</code></pre> <p></p> <p>You can annotate your <code>Dockerfile</code> and the image by using the instruction <code>LABEL</code>. You can give it any key and value with <code>&lt;key&gt;=&lt;value&gt;</code>. However, it is recommended to use the Open Container Initiative (OCI) keys.</p> <p>Exercise: Annotate our <code>Dockerfile</code> with the OCI keys on the creation date, author and description. After that, check whether this has been passed to the actual image with <code>docker inspect</code>. </p> <p>Note</p> <p>You can type <code>LABEL</code> for each key-value pair, but you can also have it on one line by seperating the key-value pairs by a space, e.g.:</p> <pre><code>LABEL keyx=\"valuex\" keyy=\"valuey\"\n</code></pre> Answer <p>The <code>Dockerfile</code> would look like:</p> <pre><code>FROM python:3.9.16\n\nLABEL org.opencontainers.image.created=\"2022-04-12\" \\\n    org.opencontainers.image.authors=\"Geert van Geest\" \\\n    org.opencontainers.image.description=\"Great container for getting all dates in a week! \\\n    You will never use a calender again\"\n\nRUN pip install pandas \n\nWORKDIR /opt\n\nCOPY daterange.py .\n\nENV PATH=/opt:$PATH\n\n# note that if you want to be able to combine the two\n# both ENTRYPOINT and CMD need to written in the exec form\nENTRYPOINT [\"daterange.py\"]\n\n# default option (if positional arguments are not specified)\nCMD [\"--date\", \"20220226\"]\n</code></pre> <p>The <code>Config</code> record in the output of <code>docker inspect</code> was updated with:</p> <pre><code>\"Labels\": {\n            \"org.opencontainers.image.authors\": \"Geert van Geest\",\n            \"org.opencontainers.image.created\": \"2022-04-12\",\n            \"org.opencontainers.image.description\": \"Great container for getting all dates in a week!     You will never use a calender again\"\n        }\n</code></pre> <p></p> <p>In this exercise, we will use a different base image from the jupyter docker image stack. JupyterLab is a nice browser interface that you can use for a.o. programming in python. With the image we are creating we will be able to run jupyter lab inside a container.  Check out the <code>Dockerfile</code>:</p> <pre><code>FROM jupyter/base-notebook:python-3.9\n\nRUN pip install pandas\n</code></pre> <p>This will create an image from the existing <code>python</code> image. It will also install <code>jupyterlab</code> with <code>pip</code>. As a default command it starts a jupyter notebook at port 8888.</p> <p>Ports</p> <p>We have specified here that jupyter lab should use port 8888. However, this inside the container. We can not connect to it yet with our browser.</p> <p>Exercise: Build an image based on this <code>Dockerfile</code> and give it a meaningful name.</p> Answer x86_64 / AMD64ARM64 (MacOS M1 chip) <pre><code>docker build -t jupyter-lab .\n</code></pre> <pre><code>export DOCKER_DEFAULT_PLATFORM=linux/amd64\ndocker build -t jupyter-lab .\n</code></pre> <p>You can now run a container from the image. However, you will have to tell docker where to publish port 8888 from the docker container with <code>-p [HOSTPORT:CONTAINERPORT]</code>. We choose to publish it to the same port number:</p> <pre><code>docker run --rm -it -p 8888:8888 jupyter-lab\n</code></pre> <p>Networking</p> <p>More info on docker container networking here</p> <p>By running the above command, a container will be started exposing jupyterhub at port 8888 at localhost. You can approach the instance of jupyterhub by typing <code>localhost:8888</code> in your browser. You will be asked for a token. You can find this token in the terminal from which you have started the container.</p> <p>We can make this even more interesting by mounting a local directory to the container running the jupyter-lab image:</p> <pre><code>docker run \\\n-it \\\n--rm \\\n-p 8888:8888 \\\n--mount type=bind,source=/Users/myusername/working_dir,target=/working_dir/ \\\njupyter-lab\n</code></pre> <p>By doing this you have a completely isolated and shareable python environment running jupyter lab, but with your local files available to it. Pretty neat right? </p> <p>Note</p> <p>Jupyter has a wide range of pre-built images available here.</p>"},{"location":"course_material/day1/introduction_containers/","title":"Introduction to containers","text":""},{"location":"course_material/day1/introduction_containers/#learning-outcomes","title":"Learning outcomes","text":"<p>After having completed this chapter you will be able to:</p> <ul> <li>Discriminate between an image and a container</li> <li>Run a docker container from dockerhub interactively</li> <li>Validate the available containers and their status</li> </ul>"},{"location":"course_material/day1/introduction_containers/#material","title":"Material","text":"<p>General introduction:</p> <p> Download the presentation</p> <p>Introduction to containers:</p> <p> Download the presentation</p>"},{"location":"course_material/day1/introduction_containers/#exercises","title":"Exercises","text":"<p>We recommend using a code editor like VScode or Sublime text. If you don\u2019t know which one to chose, take VScode as we can provide most support for this editor. </p> <p>If working on Windows</p> <p>If you are working on Windows, it is easiest to work with WSL2. With VScode use the WSL extension. Make sure you install the latest versions before you install docker. In principle, you can also use a native shell like PowerShell, but this might result into some issues with bind mounting directories.</p> <p>Work in projects</p> <p>We recommend to work in a project folder. This will make it easier to find your files and to share them with others. You can create a project folder anywhere on your computer. For example, you can create a folder <code>projects</code> in your home directory and then create a subfolder <code>container-course</code> in it. You can then open this folder in VScode.</p> <p>Let\u2019s create our first container from an existing image. We do this with the image <code>ubuntu</code>, generating an environment with a minimal installation of ubuntu.  </p> <pre><code>docker run -it ubuntu\n</code></pre> <p>This will give you an interactive shell into the created container (this interactivity was invoked by the options <code>-i</code> and <code>-t</code>) .</p> <p>Exercise: Check out the operating system of the container by typing <code>cat /etc/os-release</code> in the container\u2019s shell. Are we really in an ubuntu environment?</p> Answer <p>Yes:</p> <pre><code>root@33bd068de5e2:/# cat /etc/os-release\nPRETTY_NAME=\"Ubuntu 24.04 LTS\"\nNAME=\"Ubuntu\"\nVERSION_ID=\"24.04\"\nVERSION=\"24.04 LTS (Noble Numbat)\"\nVERSION_CODENAME=noble\nID=ubuntu\nID_LIKE=debian\nHOME_URL=\"https://www.ubuntu.com/\"\nSUPPORT_URL=\"https://help.ubuntu.com/\"\nBUG_REPORT_URL=\"https://bugs.launchpad.net/ubuntu/\"\nPRIVACY_POLICY_URL=\"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\"\nUBUNTU_CODENAME=noble\nLOGO=ubuntu-logo\n</code></pre> <p>Where does the image come from?</p> <p>If the image <code>ubuntu</code> was not on your computer yet, <code>docker</code> will search and try to get them from dockerhub, and download it.</p> <p>Exercise: Run the command <code>whoami</code> in the docker container. Who are you?</p> Answer <p>The command <code>whoami</code> returns the current user. In the container <code>whoami</code> will return <code>root</code>. This means you are the <code>root</code> user i.e. within the container you are admin and can basically change anything.  </p> <p>Check out the container panel at the Docker dashboard (the Docker gui) or open another host terminal and type:</p> <pre><code>docker container ls -a\n</code></pre> <p>Exercise: What is the container status?</p> Answer <p>In Docker dashboard you can see that the shell is running:</p> <p> </p> <p>The output of <code>docker container ls -a</code> is:</p> <pre><code>CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES\n27f7d11608de   ubuntu    \"/bin/bash\"   7 minutes ago   Up 6 minutes             great_moser\n</code></pre> <p>Also showing you that the <code>STATUS</code> is <code>Up</code>.</p> <p>Now let\u2019s install some software in our <code>ubuntu</code> environment. We\u2019ll install some simple software called <code>figlet</code>. Type into the container shell:</p> <pre><code>apt-get update\napt-get install figlet\n</code></pre> <p>This will give some warnings</p> <p>This installation will give some warnings. It\u2019s safe to ignore them.</p> <p>Now let\u2019s try it out. Type into the container shell:</p> <pre><code>figlet 'SIB courses are great!'\n</code></pre> <p>Now you have installed and used software <code>figlet</code> in an <code>ubuntu</code> environment (almost) completely separated from your host computer. This already gives you an idea of the power of containerization.</p> <p>Exit the shell by typing <code>exit</code>. Check out the container panel of Docker dashboard or type:</p> <pre><code>docker container ls -a\n</code></pre> <p>Exercise: What is the container status?</p> Answer <p><code>docker container ls -a</code> gives:</p> <pre><code>CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS                     PORTS     NAMES\n27f7d11608de   ubuntu    \"/bin/bash\"   15 minutes ago   Exited (0) 8 seconds ago             great_moser\n</code></pre> <p>Showing that the container has exited, meaning it\u2019s not running.</p>"},{"location":"course_material/day1/managing_docker/","title":"Managing containers and images","text":""},{"location":"course_material/day1/managing_docker/#learning-outcomes","title":"Learning outcomes","text":"<p>After having completed this chapter you will be able to:</p> <ul> <li>Explain the concept of layers in the context of docker containers and images</li> <li>Use the command line to restart and re-attach to an exited container</li> <li>Create a new image with <code>docker commit</code></li> <li>List locally available images with <code>docker image ls</code></li> <li>Run a command inside a container non-interactively</li> <li>Use <code>docker image inspect</code> to get more information on an image</li> <li>Use the command line to prune dangling images and stopped containers</li> <li>Rename and tag a docker image</li> <li>Push a newly created image to dockerhub</li> <li>Use the option <code>--mount</code> to bind mount a host directory to a container</li> </ul>"},{"location":"course_material/day1/managing_docker/#material","title":"Material","text":"<p> Download the presentation</p> <ul> <li>Overview of how docker works</li> <li>More on bind mounts</li> <li>Docker volumes in general</li> </ul>"},{"location":"course_material/day1/managing_docker/#exercises","title":"Exercises","text":""},{"location":"course_material/day1/managing_docker/#restarting-an-exited-container","title":"Restarting an exited container","text":"<p>If you would like to go back to your container with the <code>figlet</code> installation, you could try to run again:</p> <pre><code>docker run -it ubuntu\n</code></pre> <p>Exercise: Run the above command. Is your <code>figlet</code> installation still there? Why?</p> <p>Hint</p> <p>Check the status of your containers:</p> <pre><code>docker container ls -a\n</code></pre> Answer <p>No, the installation is gone. Another container was created from the same ubuntu image, without the <code>figlet</code> installation. Running the command <code>docker container ls -a</code> results in:</p> <pre><code>CONTAINER ID   IMAGE     COMMAND       CREATED              STATUS                     PORTS     NAMES\n8d7c4c611b70   ubuntu    \"/bin/bash\"   About a minute ago   Up About a minute                    kind_mendel\n27f7d11608de   ubuntu    \"/bin/bash\"   27 minutes ago       Exited (0) 2 minutes ago             great_moser\n</code></pre> <p>In this case the container <code>great_moser</code> contains the <code>figlet</code> installation. But we have exited that container. We created a new container (<code>kind_mendel</code> in this case) with a fresh environment created from the original <code>ubuntu</code> image.</p> <p>To restart your first created container, you\u2019ll have to look up its name. You can find it in the Docker dashboard, or with <code>docker container ls -a</code>.</p> <p>Container names</p> <p>The container name is the funny combination of two words separated by <code>_</code>, e.g.: <code>nifty_sinoussi</code>. Alternatively you can use the container ID (the first column of the output of <code>docker container ls</code>)</p> <p>To restart a container you can use:</p> <pre><code>docker start [CONTAINER NAME]\n</code></pre> <p>And after that to re-attach to the shell:</p> <pre><code>docker attach [CONTAINER NAME]\n</code></pre> <p>And you\u2019re back in the container shell.</p> <p>Exercise: Run the <code>docker start</code> and <code>docker attach</code> commands for the container that is supposed to contain the <code>figlet</code> installation. Is the installation of <code>figlet</code> still there?</p> Answer <p>yes:</p> <pre><code>figlet 'try some more text!'\n</code></pre> <p>Should give you output.</p> <p><code>docker attach</code> and <code>docker exec</code></p> <p>In addition to <code>docker attach</code>, you can also \u201cre-attach\u201d a container with <code>docker exec</code>. However, these two are quite different. While <code>docker attach</code> gets you back to your stopped shell process, <code>docker exec</code> creates a new one (more information on stackoverflow). The command <code>docker exec</code> enables you therefore to have multiple shells open in the same container. That can be convenient if you have one shell open with a program running in the foreground, and another one for e.g. monitoring. An example for using <code>docker exec</code> on a running container:</p> <pre><code>docker exec -it [CONTAINER NAME] /bin/bash\n</code></pre> <p>Note that  <code>docker exec</code> requires a CMD, it doesn\u2019t use the default.</p>"},{"location":"course_material/day1/managing_docker/#creating-a-new-image","title":"Creating a new image","text":"<p>You can store your changes and create a new image based on the <code>ubuntu</code> image like this:</p> <pre><code>docker commit [CONTAINER NAME] ubuntu-figlet\n</code></pre> <p>Exercise: Exit the container shell and run the above command  in your local terminal (replace <code>[CONTAINER NAME]</code> with the name of the container containing the <code>figlet</code> installation). Check out <code>docker image ls</code>. What have we just created?</p> Answer <p>A new image called <code>ubuntu-figlet</code> based on the status of the container. The output of <code>docker image ls</code> should look like:</p> <pre><code>REPOSITORY                        TAG       IMAGE ID       CREATED         SIZE\nubuntu-figlet                     latest    e08b999c7978   4 seconds ago   101MB\nubuntu                            latest    f63181f19b2f   29 hours ago    72.9MB\n</code></pre> <p>Now you can generate a new container based on the new image:</p> <pre><code>docker run -it ubuntu-figlet\n</code></pre> <p>Exercise: Run the above command. Is the <code>figlet</code> installation in the created container?</p> Answer <p>yes</p>"},{"location":"course_material/day1/managing_docker/#commands","title":"Commands","text":"<p>The second positional argument of <code>docker run</code> can be a command followed by its arguments. So, we could run a container non-interactively (without <code>-it</code>), and just let it run a single command:</p> <pre><code>docker run ubuntu-figlet figlet 'non-interactive run'\n</code></pre> <p>Resulting in just the output of the <code>figlet</code> command.</p> <p>In the previous exercises we have run containers without a command as positional argument. This doesn\u2019t mean that no command has been run, because the container would do nothing without a command. The default command is stored in the image, and you can find it by <code>docker image inspect [IMAGE NAME]</code>.  </p> <p>Exercise: Have a look at the output of <code>docker image inspect</code>, particularly at <code>\"Config\"</code> (ignore <code>\"ContainerConfig\"</code> for now). What is the default command (<code>CMD</code>) of the ubuntu image?</p> Answer <p>Running <code>docker image inspect ubuntu</code> gives (amongst other information):</p> <pre><code>\"Cmd\": [\n    \"/bin/bash\"\n],\n</code></pre> <p>In the case of the ubuntu the default command is <code>bash</code>, returning a shell in <code>bash</code> (i.e. Bourne again shell). Adding the options <code>-i</code> and <code>-t</code> (<code>-it</code>) to your <code>docker run</code> command will therefore result in an interactive <code>bash</code> shell. You can modify this default behaviour. More on that later, when we will work on Dockerfiles.</p> <p>The difference between <code>Config</code> and <code>ContainerConfig</code></p> <p>The configuration at <code>Config</code> represents the image, the configuration at <code>ContainerConfig</code> the last step during the build of the image, i.e. the last layer. More info e.g. at this post at stackoverflow.</p>"},{"location":"course_material/day1/managing_docker/#removing-containers","title":"Removing containers","text":"<p>In the meantime, with every call of <code>docker run</code> we have created a new container (check your containers with <code>docker container ls -a</code>). You probably don\u2019t want to remove those one-by-one. These two commands are very useful to clean up your Docker cache:</p> <ul> <li><code>docker container prune</code>: removes stopped containers</li> <li><code>docker image prune</code>: removes dangling images (i.e. images without a name)</li> </ul> <p>So, remove your stopped containers with:</p> <pre><code>docker container prune\n</code></pre> <p>Unless you\u2019re developing further on a container, or you\u2019re using it for an analysis, you probably want to get rid of it once you have exited the container. You can do this with adding <code>--rm</code> to your <code>docker run</code> command, e.g.:</p> <pre><code>docker run --rm ubuntu-figlet figlet 'non-interactive run'\n</code></pre>"},{"location":"course_material/day1/managing_docker/#pushing-to-dockerhub","title":"Pushing to dockerhub","text":"<p>Now that we have created our first own docker image, we can store it and share it with the world on docker hub. Before we get there, we first have to (re)name and tag it.</p> <p>Before pushing an image to dockerhub, <code>docker</code> has to know to which user and which repository the image should be added. That information should be in the name of the image, like this: <code>user/imagename</code>. We can rename an image with <code>docker tag</code> (which is a bit of misleading name for the command). So we could push to dockerhub like this:</p> <pre><code>docker tag ubuntu-figlet [USER NAME]/ubuntu-figlet\ndocker push [USER NAME]/ubuntu-figlet\n</code></pre> <p>If on Linux</p> <p>If you are on Linux and haven\u2019t connected to docker hub before, you will have login first. To do that, run:</p> <pre><code>docker login\n</code></pre> <p>How docker makes money</p> <p>All images pushed to dockerhub are open to the world. With a free account you can have one image on dockerhub that is private. Paid accounts can have more private images, and are therefore popular for commercial organisations. As an alternative to dockerhub, you can store images locally with <code>docker save</code>.</p> <p>We didn\u2019t specify the tag for our new image. That\u2019s why <code>docker tag</code> gave it the default tag called <code>latest</code>. Pushing an image without a tag will overwrite the current image with the tag <code>latest</code> (more on (not) using <code>latest</code> here). If you want to maintain multiple versions of your image, you will have to add a tag, and push the image with that tag to dockerhub:</p> <pre><code>docker tag ubuntu-figlet [USER NAME]/ubuntu-figlet:v1\ndocker push [USER NAME]/ubuntu-figlet:v1\n</code></pre>"},{"location":"course_material/day1/managing_docker/#mounting-a-directory","title":"Mounting a directory","text":"<p>For many analyses you do calculations with files or scripts that are on your host (local) computer. But how do you make them available to a docker container? You can do that in several ways, but here we will use bind-mount. You can bind-mount a directory with <code>-v</code> (<code>--volume</code>) or <code>--mount</code>. Most old-school <code>docker</code> users will use <code>-v</code>, but <code>--mount</code> syntax is easier to understand and now recommended, so we will use the latter here:</p> <pre><code>docker run \\\n--mount type=bind,source=/host/source/path,target=/path/in/container \\\n[IMAGE]\n</code></pre> <p>The target directory will be created if it does not yet exist. The source directory should exist.</p> <p>MobaXterm users</p> <p>You can specify your local path with the Windows syntax (e.g. <code>C:\\Users\\myusername</code>). However, you will have to use forward slashes (<code>/</code>) instead of backward slashes (<code>\\</code>). Therefore, mounting a directory would look like:</p> <pre><code>docker run \\\n--mount type=bind,source=C:/Users/myusername,target=/path/in/container \\\n[IMAGE]\n</code></pre> <p>Do not use autocompletion or variable substitution (e.g. <code>$PWD</code>) in MobaXterm, since these point to \u2018emulated\u2019 paths, and are not passed properly to the docker command.</p> <p>Using docker from Windows PowerShell</p> <p>Most of the syntax for <code>docker</code> is the same for both PowerShell and UNIX-based systems. However, there are some differences, e.g. in Windows, directories in file paths are separated by <code>\\</code> instead of <code>/</code>. Also, line breaks are not escaped by <code>\\</code> but by `.</p> <p>Exercise: Mount a host (local) directory to a target directory <code>/working_dir</code> in a container created from the <code>ubuntu-figlet</code> image and run it interactively. Check whether the target directory has been created.</p> Answer <p>e.g. on Mac OS this would be:</p> <pre><code>docker run \\\n-it \\\n--mount type=bind,source=/Users/myusername/working_dir,target=/working_dir/ \\\nubuntu-figlet\n</code></pre> <p>This creates a directory called <code>working_dir</code> in the root directory (<code>/</code>):</p> <pre><code>root@8d80a8698865:/# ls\nbin   dev  home  lib32  libx32  mnt  proc  run   srv  tmp  var\nboot  etc  lib   lib64  media   opt  root  sbin  sys  usr  working_dir\n</code></pre> <p>This mounted directory is both available for the host (locally) and for the container. You can therefore e.g. copy files in there, and write output generated by the container.</p> <p>Exercise: Write the output of <code>figlet \"testing mounted dir\"</code> to a file in <code>/working_dir</code>. Check whether it is available on the host (locally) in the source directory.</p> <p>Hint</p> <p>You can write the output of <code>figlet</code> to a file like this: <pre><code>figlet 'some string' &gt; file.txt\n</code></pre></p> Answer <pre><code>root@8d80a8698865:/# figlet 'testing mounted dir' &gt; /working_dir/figlet_output.txt\n</code></pre> <p>This should create a file in both your host (local) source directory and the target directory in the container called <code>figlet_output.txt</code>.</p> <p>Using files on the host</p> <p>This of course also works the other way around. If you would have a file on the host with e.g. a text, you can copy it into your mounted directory, and it will be available to the container.</p>"},{"location":"course_material/day1/managing_docker/#extra-managing-permissions","title":"Extra: Managing permissions","text":"<p>Depending on your system, the user ID and group ID will be taken over from the user inside the container. If the user inside the container is root, this will be root. That\u2019s a bit inconvenient if you just want to run the container as a regular user (for example in certain circumstances your container could write in <code>/</code>). To do that, use the <code>-u</code> option, and specify the group ID and user ID like this:</p> <pre><code>docker run -u [uid]:[gid]\n</code></pre> <p>So, e.g.:</p> <pre><code>docker run \\\n-it \\\n-u 1000:1000 \\\n--mount type=bind,source=/Users/myusername/working_dir,target=/working_dir/ \\\nubuntu-figlet\n</code></pre> <p>If you want docker to take over your current uid and gid, you can use:</p> <pre><code>docker run -u \"$(id -u):$(id -g)\"\n</code></pre> <p>This behaviour is different on MacOS and MobaXterm</p> <p>On MacOS and in the local shell of MobaXterm the uid and gid are taken over from the user running the container (even if you set <code>-u</code> as 0:0), i.e. your current ID. More info on stackoverflow.</p> <p>Exercise: Start an interactive container based on the <code>ubuntu-figlet</code> image, bind-mount a local directory and take over your current <code>uid</code> and <code>gid</code>. Write the output of a <code>figlet</code> command to a file in the mounted directory. Who and which group owns the file inside the container? And outside the container? Answer the same question but now run the container without setting <code>-u</code>.</p> Answer LinuxMacOSMobaXterm <p>Running <code>ubuntu-figlet</code> interactively while taking over <code>uid</code> and <code>gid</code> and mounting my current directory:</p> <p><pre><code>docker run -it --mount type=bind,source=$PWD,target=/data -u \"$(id -u):$(id -g)\" ubuntu-figlet\n</code></pre> Inside container:</p> <pre><code>I have no name!@e808d7c36e7c:/$ id\nuid=1000 gid=1000 groups=1000\n</code></pre> <p>So, I have taken over uid 1000 and gid 1000.</p> <pre><code>I have no name!@e808d7c36e7c:/$ cd /data\nI have no name!@e808d7c36e7c:/data$ figlet 'uid set' &gt; uid_set.txt\nI have no name!@e808d7c36e7c:/data$ ls -lh\n-rw-r--r-- 1 1000 1000 0 Mar  400 13:37 uid_set.txt\n</code></pre> <p>So the file belongs to user 1000, and group 1000.</p> <p>Outside container:</p> <pre><code>ubuntu@ip-172-31-33-21:~$ ls -lh\n-rw-r--r-- 1 ubuntu ubuntu 400 Mar  5 13:37 uid_set.txt\n</code></pre> <p>Which makes sense:</p> <pre><code>ubuntu@ip-172-31-33-21:~$ id\nuid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu)\n</code></pre> <p>Running <code>ubuntu-figlet</code> interactively without taking over <code>uid</code> and <code>gid</code>:</p> <p><pre><code>docker run -it --mount type=bind,source=$PWD,target=/data ubuntu-figlet\n</code></pre> Inside container:</p> <pre><code>root@fface8afb220:/# id\nuid=0(root) gid=0(root) groups=0(root)\n</code></pre> <p>So, uid and gid are <code>root</code>.</p> <pre><code>root@fface8afb220:/# cd /data\nroot@fface8afb220:/data# figlet 'uid unset' &gt; uid_unset.txt\nroot@fface8afb220:/data# ls -lh\n-rw-r--r-- 1 1000 1000 400 Mar  5 13:37 uid_set.txt\n-rw-r--r-- 1 root root 400 Mar  5 13:40 uid_unset.txt\n</code></pre> <p>Outside container:</p> <pre><code>ubuntu@ip-172-31-33-21:~$ ls -lh\n-rw-r--r-- 1 ubuntu ubuntu 0 Mar  5 13:37 uid_set.txt\n-rw-r--r-- 1 root   root   0 Mar  5 13:40 uid_unset.txt\n</code></pre> <p>So, the uid and gid 0 (root:root) are taken over.</p> <p>Running <code>ubuntu-figlet</code> interactively while taking over <code>uid</code> and <code>gid</code> and mounting my current directory:</p> <p><pre><code>docker run -it --mount type=bind,source=$PWD,target=/data -u \"$(id -u):$(id -g)\" ubuntu-figlet\n</code></pre> Inside container:</p> <p><pre><code>I have no name!@e808d7c36e7c:/$ id\nuid=503 gid=20(dialout) groups=20(dialout)\n</code></pre> So, the container has taken over uid 503 and group 20</p> <pre><code>I have no name!@e808d7c36e7c:/$ cd /data\nI have no name!@e808d7c36e7c:/data$ figlet 'uid set' &gt; uid_set.txt\nI have no name!@e808d7c36e7c:/data$ ls -lh\n-rw-r--r--  1 503 dialout    400 Mar  5 13:11 uid_set.txt\n</code></pre> <p>So the file belongs to user 503, and the group <code>dialout</code>.</p> <p>Outside container:</p> <pre><code>mac-34392:~ geertvangeest$ ls -lh\n-rw-r--r--   1 geertvangeest  staff     400B Mar  5 14:11 uid_set.txt\n</code></pre> <p>Which are the same as inside the container:</p> <pre><code>mac-34392:~ geertvangeest$ echo \"$(id -u):$(id -g)\"\n503:20\n</code></pre> <p>The <code>uid</code> 503 was nameless in the docker container. However the group 20 already existed in the ubuntu container, and was named <code>dialout</code>.</p> <p>Running <code>ubuntu-figlet</code> interactively without taking over <code>uid</code> and <code>gid</code>:</p> <p><pre><code>docker run -it --mount type=bind,source=$PWD,target=/data ubuntu-figlet\n</code></pre> Inside container:</p> <pre><code>root@fface8afb220:/# id\nuid=0(root) gid=0(root) groups=0(root)\n</code></pre> <p>So, inside the container I am <code>root</code>. Creating new files will lead to ownership of <code>root</code> inside the container:</p> <pre><code>root@fface8afb220:/# cd /data\nroot@fface8afb220:/data# figlet 'uid unset' &gt; uid_unset.txt\nroot@fface8afb220:/data# ls -lh\n-rw-r--r--  1 503 dialout    400 Mar  5 13:11 uid_set.txt\n-rw-r--r--  1 root root    400 Mar  5 13:25 uid_unset.txt\n</code></pre> <p>Outside container:</p> <pre><code>mac-34392:~ geertvangeest$ ls -lh\n-rw-r--r--   1 geertvangeest  staff     400B Mar  5 14:11 uid_set.txt\n-rw-r--r--   1 geertvangeest  staff     400B Mar  5 14:15 uid_unset.txt\n</code></pre> <p>So, the uid and gid 0 (root:root) are not taken over. Instead, the uid and gid of the user running docker were used.</p> <p>Running <code>ubuntu-figlet</code> interactively while taking over <code>uid</code> and <code>gid</code> and mounting to a  specfied directory:</p> <p><pre><code>docker run -it --mount type=bind,source=C:/Users/geert/data,target=/data -u \"$(id -u):$(id -g)\" ubuntu-figlet\n</code></pre> Inside container:</p> <p><pre><code>I have no name!@e808d7c36e7c:/$ id\nuid=1003 gid=513 groups=513\n</code></pre> So, the container has taken over uid 1003 and group 513</p> <pre><code>I have no name!@e808d7c36e7c:/$ cd /data\nI have no name!@e808d7c36e7c:/data$ figlet 'uid set' &gt; uid_set.txt\nI have no name!@e808d7c36e7c:/data$ ls -lh\n-rw-r--r--  1 1003 513    400 Mar  5 13:11 uid_set.txt\n</code></pre> <p>So the file belongs to user 1003, and the group 513.</p> <p>Outside container:</p> <pre><code>/home/mobaxterm/data$ ls -lh\n-rwx------   1 geert  UserGrp     400 Mar  5 14:11 uid_set.txt\n</code></pre> <p>Which are the same as inside the container:</p> <pre><code>/home/mobaxterm/data$ echo \"$(id -u):$(id -g)\"\n1003:513\n</code></pre> <p>Running <code>ubuntu-figlet</code> interactively without taking over <code>uid</code> and <code>gid</code>:</p> <p><pre><code>docker run -it --mount type=bind,source=C:/Users/geert/data,target=/data ubuntu-figlet\n</code></pre> Inside container:</p> <pre><code>root@fface8afb220:/# id\nuid=0(root) gid=0(root) groups=0(root)\n</code></pre> <p>So, inside the container I am <code>root</code>. Creating new files will lead to ownership of <code>root</code> inside the container:</p> <pre><code>root@fface8afb220:/# cd /data\nroot@fface8afb220:/data# figlet 'uid unset' &gt; uid_unset.txt\nroot@fface8afb220:/data# ls -lh\n-rw-r--r--  1 1003 503    400 Mar  5 13:11 uid_set.txt\n-rw-r--r--  1 root root    400 Mar  5 13:25 uid_unset.txt\n</code></pre> <p>Outside container:</p> <pre><code>/home/mobaxterm/data$ ls -lh\n-rwx------   1 geert  UserGrp     400 Mar  5 14:11 uid_set.txt\n-rwx------   1 geert  UserGrp     400 Mar  5 14:15 uid_unset.txt\n</code></pre> <p>So, the uid and gid 0 (root:root) are not taken over. Instead, the uid and gid of the user running docker were used.</p>"}]}